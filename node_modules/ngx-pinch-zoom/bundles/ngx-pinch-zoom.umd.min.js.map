{"version":3,"sources":["ng://ngx-pinch-zoom/lib/pinch-zoom.component.ts","ng://ngx-pinch-zoom/lib/pinch-zoom.module.ts"],"names":["PinchZoomComponent","elementRef","this","i","scale","initialScale","moveX","moveY","initialMoveX","initialMoveY","lastTap","draggingMode","transitionDuration","doubleTap","doubleTapScale","zoomButton","linearHorizontalSwipe","linearVerticalSwipe","autoZoomOut","events","EventEmitter","Object","defineProperty","prototype","_id","value","ngOnInit","element","contentElement","nativeElement","parentElement","elementTarget","querySelector","tagName","setBasicStyles","ondragstart","prefixes","split","window","query","join","matchMedia","matches","imgHeight","getImageHeight","imgWidth","getImageWidth","offsetHeight","offsetWidth","onMouseEnter","event","getElementPosition","isDragging","onMouseMove","preventDefault","eventType","startX","clientX","elementPosition","left","startY","clientY","top","emit","type","centeringImage","transformElement","onMouseUp","updateInitialValues","onResize","setImageWidth","touchstartHandler","touches","startClientX","startClientY","touchmoveHandler","detectSwipe","handleSwipe","detectLinearSwipe","handleLinearSwipe","length","handlePinch","touchendHandler","doubleTapDetection","toggleZoom","limitZoom","handleLimitZoom","alignImage","moveLeft","index","moveTop","initialDistance","getDistance","moveLeft0","moveLeft1","moveTop0","moveTop1","moveXC","moveYC","distance","getLinearSwipeType","imageWidth","imageHeight","enlargedImageWidth","enlargedImageHeight","moveXRatio","moveYRatio","newImageWidth","newImageHeight","Math","abs","sqrt","pow","pageX","pageY","getElementsByTagName","style","display","height","alignItems","justifyContent","transformOrigin","hostDisplay","hostOverflow","hostHeight","containerHeight","imgElement","maxWidth","maxHeight","duration","transition","transform","Number","_this","currentTime","Date","getTime","tapLength","clearTimeout","doubleTapTimeout","setTimeout","changedTouches","resetScale","img","transitionYRestriction","transitionXRestriction","imgOffsetTop","imgOffsetLeft","getBoundingClientRect","setMoveX","setMoveY","Component","args","selector","template","ElementRef","Input","Output","HostBinding","ViewChild","HostListener","PinchZoomModule","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"qUAAA,IAAAA,EAAA,WA4EI,SAAAA,EAAoBC,GAAAC,KAAAD,WAAAA,EAxDpBC,KAAAC,EAAI,EAEJD,KAAAE,MAAQ,EACRF,KAAAG,aAAe,EAcfH,KAAAI,MAAa,EACbJ,KAAAK,MAAa,EACbL,KAAAM,aAAoB,EACpBN,KAAAO,aAAoB,EAIpBP,KAAAQ,QAAU,EACVR,KAAAS,cAAe,EAOeT,KAAAU,mBAAqB,IAC9BV,KAAAW,WAAY,EACNX,KAAAY,eAAiB,EACtBZ,KAAAa,YAAa,EACDb,KAAAc,uBAAwB,EAC1Bd,KAAAe,qBAAsB,EAC9Bf,KAAAgB,aAAc,EAU5BhB,KAAAiB,OAA4B,IAAIC,EAAAA,aAggB9C,OAxgBIC,OAAAC,eACItB,EAAAuB,UAAA,KAAE,KAGN,WACI,OAAOrB,KAAKsB,SALhB,SACOC,GACHvB,KAAKsB,IAAMC,mCAgBfzB,EAAAuB,UAAAG,SAAA,WACIxB,KAAKyB,QAAUzB,KAAK0B,eAAeC,cACnC3B,KAAK4B,cAAgB5B,KAAKD,WAAW4B,cACrC3B,KAAK6B,cAAgB7B,KAAKyB,QAAQK,cAAc,KAAKC,QAErD/B,KAAKgC,iBAELhC,KAAKyB,QAAQQ,YAAW,WAAS,OAAA,IAGrCd,OAAAC,eAAItB,EAAAuB,UAAA,gBAAa,KAAjB,eACQa,EAAW,4BAA4BC,MAAM,KAKjD,GAAK,iBAAkBC,OACnB,OAAO,MALOC,EAUdA,EAAQ,CAAC,IAAKH,EAASI,KAAK,oBAAqB,SAAU,KAAKA,KAAK,IACzE,OAXkBD,EAWRA,EAVCD,OAAOG,WAAWF,GAAOG,yCAaxCrB,OAAAC,eAAItB,EAAAuB,UAAA,aAAU,KAAd,eACUoB,EAAYzC,KAAK0C,iBACjBC,EAAW3C,KAAK4C,gBAEtB,OAAiB,EAAb5C,KAAKE,MACEuC,EAAYzC,KAAKE,MAAQF,KAAK4B,cAAciB,cAC5CF,EAAW3C,KAAKE,MAAQF,KAAK4B,cAAckB,YAEnC,IAAf9C,KAAKE,MACEuC,EAAYzC,KAAK4B,cAAciB,cAC/BF,EAAW3C,KAAK4B,cAAckB,iBAFzC,mCAWJhD,EAAAuB,UAAA0B,aADA,SACaC,GACThD,KAAKiD,qBAEDjD,KAAKkD,aACLlD,KAAKS,cAAe,IAK5BX,EAAAuB,UAAA8B,YADA,SACYH,GACJhD,KAAKS,eACLuC,EAAMI,iBAEDpD,KAAKqD,YACNrD,KAAKsD,OAASN,EAAMO,QAAUvD,KAAKwD,gBAAgBC,KACnDzD,KAAK0D,OAASV,EAAMW,QAAU3D,KAAKwD,gBAAgBI,KAGvD5D,KAAKqD,UAAY,QACjBrD,KAAKiB,OAAO4C,KAAK,CACbC,KAAM,QACN1D,MAAOJ,KAAKI,MACZC,MAAOL,KAAKK,QAGhBL,KAAKI,MAAQJ,KAAKM,cAAiB0C,EAAMO,QAAUvD,KAAKwD,gBAAgBC,KAAQzD,KAAKsD,QACrFtD,KAAKK,MAAQL,KAAKO,cAAiByC,EAAMW,QAAU3D,KAAKwD,gBAAgBI,IAAO5D,KAAK0D,QAEpF1D,KAAK+D,iBACL/D,KAAKgE,iBAAiB,KAK9BlE,EAAAuB,UAAA4C,UADA,SACUjB,GACNhD,KAAKS,cAAe,EACpBT,KAAKkE,sBACLlE,KAAKqD,UAAY,IASrBvD,EAAAuB,UAAA8C,SADA,SACSnB,GACLhD,KAAKoE,gBACLpE,KAAKgE,iBAAiBhE,KAAKU,qBAI/BZ,EAAAuB,UAAAgD,kBADA,SACkBrB,GACdhD,KAAKiD,qBAEAjD,KAAKqD,YACNrD,KAAKsD,OAASN,EAAMsB,QAAQ,GAAGf,QAAUvD,KAAKwD,gBAAgBC,KAC9DzD,KAAK0D,OAASV,EAAMsB,QAAQ,GAAGX,QAAU3D,KAAKwD,gBAAgBI,IAE9D5D,KAAKuE,aAAevB,EAAMsB,QAAQ,GAAGf,QAAUvD,KAAKwD,gBAAgBC,KACpEzD,KAAKwE,aAAexB,EAAMsB,QAAQ,GAAGX,QAAU3D,KAAKwD,gBAAgBI,KAGxE5D,KAAKiB,OAAO4C,KAAK,CAAEC,KAAM,gBAI7BhE,EAAAuB,UAAAoD,iBADA,SACiBzB,OACPsB,EAAUtB,EAAMsB,SAGlBtE,KAAK0E,YAAYJ,IAA+B,UAAnBtE,KAAKqD,YAClCrD,KAAK2E,YAAY3B,IAIjBhD,KAAK4E,kBAAkBN,IACJ,qBAAnBtE,KAAKqD,WACc,mBAAnBrD,KAAKqD,YACLrD,KAAK6E,kBAAkB7B,IAIJ,IAAnBsB,EAAQQ,SAAiB9E,KAAKqD,WAAgC,UAAnBrD,KAAKqD,YAChDrD,KAAK+E,YAAY/B,IAKzBlD,EAAAuB,UAAA2D,gBADA,SACgBhC,GACZhD,KAAKC,EAAI,EACTD,KAAKS,cAAe,MACd6D,EAAUtB,EAAMsB,QActB,GAZItE,KAAKE,MAAQ,IACbF,KAAKE,MAAQ,GAIbF,KAAKgB,aAAkC,UAAnBhB,KAAKqD,YACzBrD,KAAKE,MAAQ,GAGjBF,KAAKiB,OAAO4C,KAAK,CAAEC,KAAM,aAGrB9D,KAAKiF,uBAAyBjF,KAAKqD,UAGnC,OAFArD,KAAKkF,WAAWlC,QAChBhD,KAAKiB,OAAO4C,KAAK,CAAEC,KAAM,eAKzB9D,KAAKmF,WAAgC,UAAnBnF,KAAKqD,WACvBrD,KAAKoF,kBAGc,UAAnBpF,KAAKqD,WAA4C,UAAnBrD,KAAKqD,WACnCrD,KAAKqF,aAGc,UAAnBrF,KAAKqD,WACc,UAAnBrD,KAAKqD,WACc,qBAAnBrD,KAAKqD,WACc,mBAAnBrD,KAAKqD,WACLrD,KAAKkE,sBAGTlE,KAAKqD,UAAY,WAEbiB,GAA8B,IAAnBA,EAAQQ,SACnB9E,KAAKqD,UAAY,KASzBvD,EAAAuB,UAAAiE,SAAA,SAASC,EAAejB,GACpB,OAAOA,EAAQiB,GAAOhC,QAAUvD,KAAKwD,gBAAgBC,MAGzD3D,EAAAuB,UAAAmE,QAAA,SAAQD,EAAejB,GACnB,OAAOA,EAAQiB,GAAO5B,QAAU3D,KAAKwD,gBAAgBI,KAGzD9D,EAAAuB,UAAAsD,YAAA,SAAY3B,GACRA,EAAMI,iBAEDpD,KAAKqD,YACNrD,KAAKsD,OAASN,EAAMsB,QAAQ,GAAGf,QAAUvD,KAAKwD,gBAAgBC,KAC9DzD,KAAK0D,OAASV,EAAMsB,QAAQ,GAAGX,QAAU3D,KAAKwD,gBAAgBI,KAGlE5D,KAAKqD,UAAY,QACjBrD,KAAKiB,OAAO4C,KAAK,CACbC,KAAM,QACN1D,MAAOJ,KAAKI,MACZC,MAAOL,KAAKK,QAGhBL,KAAKI,MAAQJ,KAAKM,cAAgBN,KAAKsF,SAAS,EAAGtC,EAAMsB,SAAWtE,KAAKsD,QACzEtD,KAAKK,MAAQL,KAAKO,cAAgBP,KAAKwF,QAAQ,EAAGxC,EAAMsB,SAAWtE,KAAK0D,QAExE1D,KAAKgE,iBAAiB,IAG1BlE,EAAAuB,UAAA0D,YAAA,SAAY/B,GACRA,EAAMI,qBAEAkB,EAAUtB,EAAMsB,QAEtB,IAAKtE,KAAKqD,UAAW,CACjBrD,KAAKyF,gBAAkBzF,KAAK0F,YAAYpB,OAElCqB,EAAY3F,KAAKsF,SAAS,EAAGhB,GAC7BsB,EAAY5F,KAAKsF,SAAS,EAAGhB,GAC7BuB,EAAW7F,KAAKwF,QAAQ,EAAGlB,GAC3BwB,EAAW9F,KAAKwF,QAAQ,EAAGlB,GAEjCtE,KAAK+F,QAAWJ,EAAYC,GAAa,EAAK5F,KAAKM,aACnDN,KAAKgG,QAAWH,EAAWC,GAAY,EAAK9F,KAAKO,aAGrDP,KAAKqD,UAAY,QACjBrD,KAAKiG,SAAWjG,KAAK0F,YAAYpB,GACjCtE,KAAKE,MAAQF,KAAKG,cAAgBH,KAAKiG,SAAWjG,KAAKyF,iBACvDzF,KAAKiB,OAAO4C,KAAK,CACbC,KAAM,QACN5D,MAAOF,KAAKE,QAGhBF,KAAKI,MAAQJ,KAAKM,cAAkBN,KAAKiG,SAAWjG,KAAKyF,gBAAmBzF,KAAK+F,OAAU/F,KAAK+F,QAChG/F,KAAKK,MAAQL,KAAKO,cAAkBP,KAAKiG,SAAWjG,KAAKyF,gBAAmBzF,KAAKgG,OAAUhG,KAAKgG,QAEhGhG,KAAKgE,iBAAiB,IAG1BlE,EAAAuB,UAAAwD,kBAAA,SAAkB7B,GACVhD,KAAKe,qBACLiC,EAAMI,iBAGVpD,KAAKC,IAEQ,EAATD,KAAKC,IACLD,KAAKqD,UAAYrD,KAAKkG,mBAAmBlD,IAGtB,qBAAnBhD,KAAKqD,YACLrD,KAAKI,MAAQJ,KAAKM,cAAiB0C,EAAMsB,QAAQ,GAAGf,QAAUvD,KAAKwD,gBAAgBC,KAAQzD,KAAKsD,QAChGtD,KAAKK,MAAQ,GAGM,mBAAnBL,KAAKqD,YACLrD,KAAKI,MAAQ,EACbJ,KAAKK,MAAQL,KAAKO,cAAiByC,EAAMsB,QAAQ,GAAGX,QAAU3D,KAAKwD,gBAAgBI,IAAO5D,KAAK0D,SAG/F1D,KAAKqD,YACLrD,KAAKiB,OAAO4C,KAAK,CACbC,KAAM9D,KAAKqD,UACXjD,MAAOJ,KAAKI,MACZC,MAAOL,KAAKK,QAEhBL,KAAKgE,iBAAiB,KAI9BlE,EAAAuB,UAAA+D,gBAAA,WACI,GAAIpF,KAAKE,MAAQF,KAAKmF,UAAU,KACtBgB,EAAanG,KAAK4C,gBAClBwD,EAAcpG,KAAK0C,iBACnB2D,EAAqBF,EAAanG,KAAKE,MACvCoG,EAAsBF,EAAcpG,KAAKE,MAEzCqG,EAAavG,KAAKI,OAASiG,EAAqBF,GAChDK,EAAaxG,KAAKK,OAASiG,EAAsBF,GAEvDpG,KAAKE,MAAQF,KAAKmF,cAEZsB,EAAgBN,EAAanG,KAAKE,MAClCwG,EAAiBN,EAAcpG,KAAKE,MAE1CF,KAAKI,OAASuG,KAAKC,IAAKL,GAAcE,EAAgBN,IACtDnG,KAAKK,OAASsG,KAAKC,KAAMJ,GAAcE,EAAiBN,IAExDpG,KAAK+D,iBACL/D,KAAKgE,iBAAiBhE,KAAKU,sBAKnCZ,EAAAuB,UAAAqD,YAAA,SAAYJ,GACR,OAA0B,IAAnBA,EAAQQ,QAA6B,EAAb9E,KAAKE,QAAcF,KAAKqD,WAG3DvD,EAAAuB,UAAAuD,kBAAA,SAAkBN,GACd,OAA0B,IAAnBA,EAAQQ,QAA+B,IAAf9E,KAAKE,QAAgBF,KAAKqD,WAG7DvD,EAAAuB,UAAA6E,mBAAA,SAAmBlD,GACf,MAAuB,qBAAnBhD,KAAKqD,WAAuD,mBAAnBrD,KAAKqD,UAUvCrD,KAAKqD,UATMsD,KAAKC,IAAI5G,KAAKsF,SAAS,EAAGtC,EAAMsB,SAAWtE,KAAKuE,cAGjD,EAFCoC,KAAKC,IAAI5G,KAAKwF,QAAQ,EAAGxC,EAAMsB,SAAWtE,KAAKwE,cAGtDxE,KAAKe,oBAAsB,iBAAmB,GAE9Cf,KAAKc,sBAAwB,mBAAqB,IAOrEhB,EAAAuB,UAAAqE,YAAA,SAAYpB,GACR,OAAOqC,KAAKE,KAAKF,KAAKG,IAAIxC,EAAQ,GAAGyC,MAAQzC,EAAQ,GAAGyC,MAAO,GAAKJ,KAAKG,IAAIxC,EAAQ,GAAG0C,MAAQ1C,EAAQ,GAAG0C,MAAO,KAGtHlH,EAAAuB,UAAAqB,eAAA,WACI,OAAO1C,KAAKyB,QAAQwF,qBAAqBjH,KAAK6B,eAAe,GAAGgB,cAGpE/C,EAAAuB,UAAAuB,cAAA,WACI,OAAO5C,KAAKyB,QAAQwF,qBAAqBjH,KAAK6B,eAAe,GAAGiB,aAGpEhD,EAAAuB,UAAAW,eAAA,WACIhC,KAAKyB,QAAQyF,MAAMC,QAAU,OAC7BnH,KAAKyB,QAAQyF,MAAME,OAAS,OAC5BpH,KAAKyB,QAAQyF,MAAMG,WAAa,SAChCrH,KAAKyB,QAAQyF,MAAMI,eAAiB,SACpCtH,KAAKyB,QAAQyF,MAAMK,gBAAkB,MAErCvH,KAAKwH,YAAc,QACnBxH,KAAKyH,aAAe,SACpBzH,KAAK0H,WAAa1H,KAAK2H,gBAEvB3H,KAAKoE,iBAGTtE,EAAAuB,UAAA+C,cAAA,eACUwD,EAAa5H,KAAKyB,QAAQwF,qBAAqBjH,KAAK6B,eAEtD+F,EAAW9C,SACX8C,EAAW,GAAGV,MAAMW,SAAW,OAC/BD,EAAW,GAAGV,MAAMY,UAAY,SAIxChI,EAAAuB,UAAA2C,iBAAA,SAAiB+D,QAAA,IAAAA,IAAAA,EAAA,IACb/H,KAAKyB,QAAQyF,MAAMc,WAAa,OAAOD,EAAQ,KAC/C/H,KAAKyB,QAAQyF,MAAMe,UAAY,wBAClBC,OAAOlI,KAAKE,OAAM,WAAWgI,OAAOlI,KAAKE,OAAM,KAAKgI,OAAOlI,KAAKI,OAAM,KAAK8H,OAAOlI,KAAKK,OAAM,KAG9GP,EAAAuB,UAAA4D,mBAAA,WAAA,IAAAkD,EAAAnI,KACI,IAAKA,KAAKW,UACN,OAAO,MAGLyH,GAAc,IAAIC,MAAOC,UACzBC,EAAYH,EAAcpI,KAAKQ,QAIrC,GAFAgI,aAAaxI,KAAKyI,kBAEdF,EAAY,KAAmB,EAAZA,EACnB,OAAO,EAEPvI,KAAKyI,iBAAmBC,WAAU,WAC9BF,aAAaL,EAAKM,mBACnB,KAEPzI,KAAKQ,QAAU4H,GAGZtI,EAAAuB,UAAA6D,WAAP,SAAkBlC,GACd,QADc,IAAAA,IAAAA,GAAA,GACY,IAAtBhD,KAAKG,aAAoB,CAEzB,GAAI6C,GAASA,EAAM2F,eAAgB,KACzBA,EAAiB3F,EAAM2F,eAE7B3I,KAAKE,MAAQF,KAAKG,aAAeH,KAAKY,eACtCZ,KAAKI,MAAQJ,KAAKM,cAAgBqI,EAAe,GAAGpF,SAAWvD,KAAKY,eAAiB,GAAKZ,KAAKwD,gBAAgBC,MAC/GzD,KAAKK,MAAQL,KAAKO,cAAgBoI,EAAe,GAAGhF,SAAW3D,KAAKY,eAAiB,GAAKZ,KAAKwD,gBAAgBI,UAE/G5D,KAAKE,MAA4B,EAApBF,KAAKG,aAClBH,KAAKI,MAAQJ,KAAKM,aAAeN,KAAKyB,QAAQqB,YAAc,EAC5D9C,KAAKK,MAAQL,KAAKO,aAAeP,KAAKyB,QAAQoB,aAAe,EAGjE7C,KAAK+D,iBACL/D,KAAKkE,sBACLlE,KAAKgE,iBAAiBhE,KAAKU,oBAC3BV,KAAKiB,OAAO4C,KAAK,CAAEC,KAAM,iBAEzB9D,KAAK4I,aACL5I,KAAKiB,OAAO4C,KAAK,CAAEC,KAAM,cAIjChE,EAAAuB,UAAAuH,WAAA,WACI5I,KAAKE,MAAQ,EACbF,KAAKI,MAAQ,EACbJ,KAAKK,MAAQ,EACbL,KAAKkE,sBACLlE,KAAKgE,iBAAiBhE,KAAKU,qBAG/BZ,EAAAuB,UAAA6C,oBAAA,WACIlE,KAAKG,aAAeH,KAAKE,MACzBF,KAAKM,aAAeN,KAAKI,MACzBJ,KAAKO,aAAeP,KAAKK,OAG7BP,EAAAuB,UAAA0C,eAAA,eACU8E,EAAM7I,KAAKyB,QAAQwF,qBAAqBjH,KAAK6B,eAAe,GAC5DvB,EAAeN,KAAKI,MACpBG,EAAeP,KAAKK,MAmB1B,OAjBiB,EAAbL,KAAKK,QACLL,KAAKK,MAAQ,GAEA,EAAbL,KAAKI,QACLJ,KAAKI,MAAQ,GAGbyI,IACA7I,KAAK8I,yBACL9I,KAAK+I,0BAELF,GAAO7I,KAAKE,MAAQ,GAChBF,KAAKI,MAAQJ,KAAKyB,QAAQqB,aAAe,EAAI9C,KAAKE,SAClDF,KAAKI,MAAQJ,KAAKyB,QAAQqB,aAAe,EAAI9C,KAAKE,QAInDI,IAAiBN,KAAKI,OAASG,IAAiBP,KAAKK,OAGzDP,EAAAuB,UAAAgE,WAAP,WAC0BrF,KAAK+D,mBAGvB/D,KAAKkE,sBACLlE,KAAKgE,iBAAiBhE,KAAKU,sBAInCZ,EAAAuB,UAAAyH,uBAAA,eACUrG,EAAYzC,KAAK0C,iBAEvB,GAAID,EAAYzC,KAAKE,MAAQF,KAAK4B,cAAciB,aAC5C7C,KAAKK,OAASL,KAAK4B,cAAciB,aAAe7C,KAAKyB,QAAQoB,aAAe7C,KAAKE,OAAS,MACvF,KACG8I,GAAiBvG,EAAYzC,KAAKyB,QAAQoB,cAAgB7C,KAAKE,MAAS,EAE1EF,KAAKK,MAAQ2I,EACbhJ,KAAKK,MAAQ2I,EACLvG,EAAYzC,KAAKE,MAAQyG,KAAKC,IAAIoC,GAAgBhJ,KAAK4B,cAAciB,aAAgB7C,KAAKK,MAAQ,IAC1GL,KAAKK,QAAWoC,EAAYzC,KAAKE,MAAQyG,KAAKC,IAAIoC,GAAgBhJ,KAAK4B,cAAciB,iBAKjG/C,EAAAuB,UAAA0H,uBAAA,eACUpG,EAAW3C,KAAK4C,gBAEtB,GAAID,EAAW3C,KAAKE,MAAQF,KAAK4B,cAAckB,YAC3C9C,KAAKI,OAASJ,KAAK4B,cAAckB,YAAc9C,KAAKyB,QAAQqB,YAAc9C,KAAKE,OAAS,MACrF,KACG+I,GAAkBtG,EAAW3C,KAAKyB,QAAQqB,aAAe9C,KAAKE,MAAS,EAEzEF,KAAKI,MAAQ6I,EACbjJ,KAAKI,MAAQ6I,EACLtG,EAAW3C,KAAKE,MAAQyG,KAAKC,IAAIqC,GAAiBjJ,KAAK4B,cAAckB,YAAe9C,KAAKI,MAAQ,IACzGJ,KAAKI,QAAWuC,EAAW3C,KAAKE,MAAQyG,KAAKC,IAAIqC,GAAiBjJ,KAAK4B,cAAckB,gBAKjGhD,EAAAuB,UAAA4B,mBAAA,WACIjD,KAAKwD,gBAAkBxD,KAAKD,WAAW4B,cAAcuH,yBAGlDpJ,EAAAuB,UAAA8H,SAAP,SAAgB5H,EAAeb,QAAA,IAAAA,IAAAA,EAAA,KAC3BV,KAAKI,MAAQmB,EACbvB,KAAKgE,iBAAiBtD,IAGnBZ,EAAAuB,UAAA+H,SAAP,SAAgB7H,EAAeb,QAAA,IAAAA,IAAAA,EAAA,KAC3BV,KAAKK,MAAQkB,EACbvB,KAAKgE,iBAAiBtD,wBAtjB7B2I,EAAAA,UAASC,KAAA,CAAC,CACPC,SAAU,2BACVC,SAAA,0+FAXAC,EAAAA,uDAgDCC,EAAAA,MAAKJ,KAAA,CAAC,sCACNI,EAAAA,MAAKJ,KAAA,CAAC,0CACNI,EAAAA,MAAKJ,KAAA,CAAC,sCACNI,EAAAA,MAAKJ,KAAA,CAAC,wCACNI,EAAAA,MAAKJ,KAAA,CAAC,8CACNI,EAAAA,MAAKJ,KAAA,CAAC,wDACNI,EAAAA,MAAKJ,KAAA,CAAC,8CACNI,EAAAA,MAAKJ,KAAA,CAAC,oCACNI,EAAAA,MAAKJ,KAAA,CAAC,0BACNI,EAAAA,sBAQAC,EAAAA,4BAEAC,EAAAA,YAAWN,KAAA,CAAC,uCACZM,EAAAA,YAAWN,KAAA,CAAC,sCACZM,EAAAA,YAAWN,KAAA,CAAC,wCAEZO,EAAAA,UAASP,KAAA,CAAC,iCAgDVQ,EAAAA,aAAYR,KAAA,CAAC,YAAa,CAAC,gCAS3BQ,EAAAA,aAAYR,KAAA,CAAC,mBAAoB,CAAC,8BAyBlCQ,EAAAA,aAAYR,KAAA,CAAC,iBAAkB,CAAC,6BAYhCQ,EAAAA,aAAYR,KAAA,CAAC,gBAAiB,CAAC,sCAM/BQ,EAAAA,aAAYR,KAAA,CAAC,aAAc,CAAC,qCAe5BQ,EAAAA,aAAYR,KAAA,CAAC,YAAa,CAAC,oCAsB3BQ,EAAAA,aAAYR,KAAA,CAAC,WAAY,CAAC,cAiX/BxJ,EApkBA,GCAAiK,EAAA,WAIA,SAAAA,KAc+B,2BAd9BC,EAAAA,SAAQV,KAAA,CAAC,CACNW,aAAc,CACVnK,GAEJoK,QAAS,CACLC,EAAAA,cAEJC,QAAS,CACLtK,GAEJuK,gBAAiB,CACbvK,OAGuBiK,EAlB/B","sourcesContent":["import {\n    Component,\n    HostBinding,\n    ElementRef,\n    HostListener,\n    OnInit,\n    ViewChild,\n    Input,\n    EventEmitter,\n    Output\n} from '@angular/core';\n\n@Component({\n    selector: 'pinch-zoom, [pinch-zoom]',\n    templateUrl: './pinch-zoom.component.html',\n    styleUrls: ['./pinch-zoom.component.css']\n})\n\nexport class PinchZoomComponent implements OnInit {\n\n    i = 0;\n\n    scale = 1;\n    initialScale = 1;\n\n    _id: any;\n    element: any;\n    elementTarget: any;\n    elementPosition: any;\n    parentElement: any;\n    eventType: any;\n\n    startX: number;\n    startY: number;\n    startClientX: number;\n    startClientY: number;\n\n    moveX: any = 0;\n    moveY: any = 0;\n    initialMoveX: any = 0;\n    initialMoveY: any = 0;\n    moveXC: number;\n    moveYC: number;\n\n    lastTap = 0;\n    draggingMode = false;\n\n    distance: number;\n    doubleTapTimeout: any;\n    initialDistance: number;\n\n    @Input('height') containerHeight: string;\n    @Input('transition-duration') transitionDuration = 200;\n    @Input('double-tap') doubleTap = true;\n    @Input('double-tap-scale') doubleTapScale = 2;\n    @Input('zoom-button') zoomButton = true;\n    @Input('linear-horizontal-swipe') linearHorizontalSwipe = false;\n    @Input('linear-vertical-swipe') linearVerticalSwipe = false;\n    @Input('auto-zoom-out') autoZoomOut = false;\n    @Input('limit-zoom') limitZoom;\n    @Input()\n    set id(value: any) {\n        this._id = value;\n    }\n    get id() {\n        return this._id;\n    }\n\n    @Output() events: EventEmitter<any> = new EventEmitter<any>();\n\n    @HostBinding('style.display') hostDisplay: string;\n    @HostBinding('style.overflow') hostOverflow: string;\n    @HostBinding('style.height') hostHeight: string;\n\n    @ViewChild('content') contentElement: ElementRef;\n\n    constructor(private elementRef: ElementRef) { }\n\n    ngOnInit() {\n        this.element = this.contentElement.nativeElement;\n        this.parentElement = this.elementRef.nativeElement;\n        this.elementTarget = this.element.querySelector('*').tagName;\n\n        this.setBasicStyles();\n\n        this.element.ondragstart = () => false;\n    }\n\n    get isTouchScreen() {\n        var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\n        var mq = function(query) {\n            return window.matchMedia(query).matches;\n        }\n\n        if (('ontouchstart' in window)) {\n            return true;\n        }\n\n        // include the 'heartz' as a way to have a non matching MQ to help terminate the join\n        // https://git.io/vznFH\n        var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\n        return mq(query);\n    }\n\n    get isDragging() {\n        const imgHeight = this.getImageHeight();\n        const imgWidth = this.getImageWidth();\n\n        if (this.scale > 1) {\n            return imgHeight * this.scale > this.parentElement.offsetHeight ||\n                   imgWidth * this.scale > this.parentElement.offsetWidth;\n        }\n        if (this.scale === 1) {\n            return imgHeight > this.parentElement.offsetHeight ||\n                   imgWidth > this.parentElement.offsetWidth;\n        }\n    }\n\n    /*\n     * Desktop listeners\n     */\n\n    @HostListener('mousedown', ['$event'])\n    onMouseEnter(event: MouseEvent): void {\n        this.getElementPosition();\n\n        if (this.isDragging) {\n            this.draggingMode = true;\n        }\n    }\n\n    @HostListener('window:mousemove', ['$event'])\n    onMouseMove(event: MouseEvent): void {\n        if (this.draggingMode) {\n            event.preventDefault();\n\n            if (!this.eventType) {\n                this.startX = event.clientX - this.elementPosition.left;\n                this.startY = event.clientY - this.elementPosition.top;\n            }\n\n            this.eventType = 'swipe';\n            this.events.emit({\n                type: 'swipe',\n                moveX: this.moveX,\n                moveY: this.moveY\n            });\n\n            this.moveX = this.initialMoveX + ((event.clientX - this.elementPosition.left) - this.startX);\n            this.moveY = this.initialMoveY + ((event.clientY - this.elementPosition.top) - this.startY);\n\n            this.centeringImage();\n            this.transformElement(0);\n        }\n    }\n\n    @HostListener('window:mouseup', ['$event'])\n    onMouseUp(event: MouseEvent): void {\n        this.draggingMode = false;\n        this.updateInitialValues();\n        this.eventType = '';\n    }\n\n\n    /*\n     * Mobile listeners\n     */\n\n    @HostListener('window:resize', ['$event'])\n    onResize(event: Event): void {\n        this.setImageWidth();\n        this.transformElement(this.transitionDuration);\n    }\n\n    @HostListener('touchstart', ['$event'])\n    touchstartHandler(event: any): void {\n        this.getElementPosition();\n\n        if (!this.eventType) {\n            this.startX = event.touches[0].clientX - this.elementPosition.left;\n            this.startY = event.touches[0].clientY - this.elementPosition.top;\n\n            this.startClientX = event.touches[0].clientX - this.elementPosition.left;\n            this.startClientY = event.touches[0].clientY - this.elementPosition.top;\n        }\n\n        this.events.emit({ type: 'touchstart' });\n    }\n\n    @HostListener('touchmove', ['$event'])\n    touchmoveHandler(event: any): void {\n        const touches = event.touches;\n\n        // Swipe\n        if (this.detectSwipe(touches) || this.eventType === 'swipe') {\n            this.handleSwipe(event);\n        }\n\n        // Linear swipe\n        if (this.detectLinearSwipe(touches) ||\n            this.eventType === 'horizontal-swipe' ||\n            this.eventType === 'vertical-swipe') {\n            this.handleLinearSwipe(event);\n        }\n\n        // Pinch\n        if (touches.length === 2 && !this.eventType || this.eventType === 'pinch') {\n            this.handlePinch(event);\n        }\n    }\n\n    @HostListener('touchend', ['$event'])\n    touchendHandler(event: any): void {\n        this.i = 0;\n        this.draggingMode = false;\n        const touches = event.touches;\n\n        if (this.scale < 1) {\n            this.scale = 1;\n        }\n\n        // Auto Zoom Out\n        if (this.autoZoomOut && this.eventType === 'pinch') {\n            this.scale = 1;\n        }\n\n        this.events.emit({ type: 'touchend' });\n\n        // Double Tap\n        if (this.doubleTapDetection() && !this.eventType) {\n            this.toggleZoom(event);\n            this.events.emit({ type: 'double-tap' });\n            return;\n        }\n\n        // Limit Zoom\n        if (this.limitZoom && this.eventType === 'pinch') {\n            this.handleLimitZoom();\n        }\n\n        if (this.eventType === 'pinch' || this.eventType === 'swipe') {\n            this.alignImage();\n        }\n\n        if (this.eventType === 'pinch' ||\n            this.eventType === 'swipe' ||\n            this.eventType === 'horizontal-swipe' ||\n            this.eventType === 'vertical-swipe') {\n            this.updateInitialValues();\n        }\n\n        this.eventType = 'touchend';\n\n        if (touches && touches.length === 0) {\n            this.eventType = '';\n        }\n    }\n\n\n    /*\n     * Handlers\n     */\n\n    moveLeft(index: number, touches): number {\n        return touches[index].clientX - this.elementPosition.left;\n    }\n\n    moveTop(index: number, touches): number {\n        return touches[index].clientY - this.elementPosition.top;\n    }\n\n    handleSwipe(event: any): void {\n        event.preventDefault();\n\n        if (!this.eventType) {\n            this.startX = event.touches[0].clientX - this.elementPosition.left;\n            this.startY = event.touches[0].clientY - this.elementPosition.top;\n        }\n\n        this.eventType = 'swipe';\n        this.events.emit({\n            type: 'swipe',\n            moveX: this.moveX,\n            moveY: this.moveY\n        });\n\n        this.moveX = this.initialMoveX + (this.moveLeft(0, event.touches) - this.startX);\n        this.moveY = this.initialMoveY + (this.moveTop(0, event.touches) - this.startY);\n\n        this.transformElement(0);\n    }\n\n    handlePinch(event: any): void {\n        event.preventDefault();\n\n        const touches = event.touches;\n\n        if (!this.eventType) {\n            this.initialDistance = this.getDistance(touches);\n\n            const moveLeft0 = this.moveLeft(0, touches);\n            const moveLeft1 = this.moveLeft(1, touches);\n            const moveTop0 = this.moveTop(0, touches);\n            const moveTop1 = this.moveTop(1, touches);\n\n            this.moveXC = ((moveLeft0 + moveLeft1) / 2) - this.initialMoveX;\n            this.moveYC = ((moveTop0 + moveTop1) / 2) - this.initialMoveY;\n        }\n\n        this.eventType = 'pinch';\n        this.distance = this.getDistance(touches);\n        this.scale = this.initialScale * (this.distance / this.initialDistance);\n        this.events.emit({ \n            type: 'pinch', \n            scale: this.scale \n        });\n\n        this.moveX = this.initialMoveX - (((this.distance / this.initialDistance) * this.moveXC) - this.moveXC);\n        this.moveY = this.initialMoveY - (((this.distance / this.initialDistance) * this.moveYC) - this.moveYC);\n\n        this.transformElement(0);\n    }\n\n    handleLinearSwipe(event: any): void {\n        if (this.linearVerticalSwipe) {\n            event.preventDefault();\n        }\n\n        this.i++;\n\n        if (this.i > 3) {\n            this.eventType = this.getLinearSwipeType(event);\n        }\n\n        if (this.eventType === 'horizontal-swipe') {\n            this.moveX = this.initialMoveX + ((event.touches[0].clientX - this.elementPosition.left) - this.startX);\n            this.moveY = 0;\n        }\n\n        if (this.eventType === 'vertical-swipe') {\n            this.moveX = 0;\n            this.moveY = this.initialMoveY + ((event.touches[0].clientY - this.elementPosition.top) - this.startY);\n        }\n\n        if (this.eventType) {\n            this.events.emit({\n                type: this.eventType,\n                moveX: this.moveX,\n                moveY: this.moveY\n            });\n            this.transformElement(0);\n        }\n    }\n\n    handleLimitZoom(){\n        if (this.scale > this.limitZoom){\n            const imageWidth = this.getImageWidth();\n            const imageHeight = this.getImageHeight();\n            const enlargedImageWidth = imageWidth * this.scale;\n            const enlargedImageHeight = imageHeight * this.scale;\n\n            const moveXRatio = this.moveX / (enlargedImageWidth - imageWidth);\n            const moveYRatio = this.moveY / (enlargedImageHeight - imageHeight);\n\n            this.scale = this.limitZoom;\n\n            const newImageWidth = imageWidth * this.scale;\n            const newImageHeight = imageHeight * this.scale;\n\n            this.moveX = -Math.abs((moveXRatio * (newImageWidth - imageWidth)));\n            this.moveY = -Math.abs((-moveYRatio * (newImageHeight - imageHeight)));\n\n            this.centeringImage();\n            this.transformElement(this.transitionDuration);\n        }\n    }\n\n\n    detectSwipe(touches: any): boolean {\n        return touches.length === 1 && this.scale > 1 && !this.eventType;\n    }\n\n    detectLinearSwipe(touches: TouchList): boolean {\n        return touches.length === 1 && this.scale === 1 && !this.eventType;\n    }\n\n    getLinearSwipeType(event: any): string {\n        if (this.eventType !== 'horizontal-swipe' && this.eventType !== 'vertical-swipe') {\n            const movementX = Math.abs(this.moveLeft(0, event.touches) - this.startClientX);\n            const movementY = Math.abs(this.moveTop(0, event.touches) - this.startClientY);\n\n            if ((movementY * 3) > movementX) {\n                return this.linearVerticalSwipe ? 'vertical-swipe' : '';\n            } else {\n                return this.linearHorizontalSwipe ? 'horizontal-swipe' : '';\n            }\n        } else {\n            return this.eventType;\n        }\n    }\n\n    getDistance(touches: any) {\n        return Math.sqrt(Math.pow(touches[0].pageX - touches[1].pageX, 2) + Math.pow(touches[0].pageY - touches[1].pageY, 2));\n    }\n\n    getImageHeight(): any {\n        return this.element.getElementsByTagName(this.elementTarget)[0].offsetHeight;\n    }\n\n    getImageWidth(): any {\n        return this.element.getElementsByTagName(this.elementTarget)[0].offsetWidth;\n    }\n\n    setBasicStyles(): void {\n        this.element.style.display = 'flex';\n        this.element.style.height = '100%';\n        this.element.style.alignItems = 'center';\n        this.element.style.justifyContent = 'center';\n        this.element.style.transformOrigin = '0 0';\n\n        this.hostDisplay = 'block';\n        this.hostOverflow = 'hidden';\n        this.hostHeight = this.containerHeight;\n\n        this.setImageWidth();\n    }\n\n    setImageWidth(): void {\n        const imgElement = this.element.getElementsByTagName(this.elementTarget);\n\n        if (imgElement.length) {\n            imgElement[0].style.maxWidth = '100%';\n            imgElement[0].style.maxHeight = '100%';\n        }\n    }\n\n    transformElement(duration: any = 50) {\n        this.element.style.transition = `all ${duration}ms`;\n        this.element.style.transform = `\n            matrix(${Number(this.scale)}, 0, 0, ${Number(this.scale)}, ${Number(this.moveX)}, ${Number(this.moveY)})`;\n    }\n\n    doubleTapDetection(): boolean {\n        if (!this.doubleTap) {\n            return false;\n        }\n\n        const currentTime = new Date().getTime();\n        const tapLength = currentTime - this.lastTap;\n\n        clearTimeout(this.doubleTapTimeout);\n\n        if (tapLength < 300 && tapLength > 0) {\n            return true;\n        } else {\n            this.doubleTapTimeout = setTimeout(() => {\n                clearTimeout(this.doubleTapTimeout);\n            }, 300);\n        }\n        this.lastTap = currentTime;\n    }\n\n    public toggleZoom(event: any = false): void {\n        if (this.initialScale === 1) {\n\n            if (event && event.changedTouches) {\n                const changedTouches = event.changedTouches;\n\n                this.scale = this.initialScale * this.doubleTapScale;\n                this.moveX = this.initialMoveX - (changedTouches[0].clientX * (this.doubleTapScale - 1) - this.elementPosition.left);\n                this.moveY = this.initialMoveY - (changedTouches[0].clientY * (this.doubleTapScale - 1) - this.elementPosition.top);\n            } else {\n                this.scale = this.initialScale * 2;\n                this.moveX = this.initialMoveX - this.element.offsetWidth / 2;\n                this.moveY = this.initialMoveY - this.element.offsetHeight / 2;\n            }\n\n            this.centeringImage();\n            this.updateInitialValues();\n            this.transformElement(this.transitionDuration);\n            this.events.emit({ type: 'zoom-in' });\n        } else {\n            this.resetScale();\n            this.events.emit({ type: 'zoom-out' });\n        }\n    }\n\n    resetScale(): void {\n        this.scale = 1;\n        this.moveX = 0;\n        this.moveY = 0;\n        this.updateInitialValues();\n        this.transformElement(this.transitionDuration);\n    }\n\n    updateInitialValues(): void {\n        this.initialScale = this.scale;\n        this.initialMoveX = this.moveX;\n        this.initialMoveY = this.moveY;\n    }\n\n    centeringImage(): boolean {\n        const img = this.element.getElementsByTagName(this.elementTarget)[0];\n        const initialMoveX = this.moveX;\n        const initialMoveY = this.moveY;\n\n        if (this.moveY > 0) {\n            this.moveY = 0;\n        }\n        if (this.moveX > 0) {\n            this.moveX = 0;\n        }\n\n        if (img) {\n            this.transitionYRestriction();\n            this.transitionXRestriction();\n        }\n        if (img && this.scale < 1) {\n            if (this.moveX < this.element.offsetWidth * (1 - this.scale)) {\n                this.moveX = this.element.offsetWidth * (1 - this.scale);\n            }\n        }\n\n        return initialMoveX !== this.moveX || initialMoveY !== this.moveY;\n    }\n\n    public alignImage(): void {\n        const isMoveChanged = this.centeringImage();\n\n        if (isMoveChanged) {\n            this.updateInitialValues();\n            this.transformElement(this.transitionDuration);\n        }\n    }\n\n    transitionYRestriction(): void {\n        const imgHeight = this.getImageHeight();\n\n        if (imgHeight * this.scale < this.parentElement.offsetHeight) {\n            this.moveY = (this.parentElement.offsetHeight - this.element.offsetHeight * this.scale) / 2;\n        } else {\n            const imgOffsetTop = ((imgHeight - this.element.offsetHeight) * this.scale) / 2;\n\n            if (this.moveY > imgOffsetTop) {\n                this.moveY = imgOffsetTop;\n            } else if ((imgHeight * this.scale + Math.abs(imgOffsetTop) - this.parentElement.offsetHeight) + this.moveY < 0) {\n                this.moveY = - (imgHeight * this.scale + Math.abs(imgOffsetTop) - this.parentElement.offsetHeight);\n            }\n        }\n    }\n\n    transitionXRestriction(): void {\n        const imgWidth = this.getImageWidth();\n\n        if (imgWidth * this.scale < this.parentElement.offsetWidth) {\n            this.moveX = (this.parentElement.offsetWidth - this.element.offsetWidth * this.scale) / 2;\n        } else {\n            const imgOffsetLeft = ((imgWidth - this.element.offsetWidth) * this.scale) / 2;\n\n            if (this.moveX > imgOffsetLeft) {\n                this.moveX = imgOffsetLeft;\n            } else if ((imgWidth * this.scale + Math.abs(imgOffsetLeft) - this.parentElement.offsetWidth) + this.moveX < 0) {\n                this.moveX = - (imgWidth * this.scale + Math.abs(imgOffsetLeft) - this.parentElement.offsetWidth);\n            }\n        }\n    }\n\n    getElementPosition(): void {\n        this.elementPosition = this.elementRef.nativeElement.getBoundingClientRect();\n    }\n\n    public setMoveX(value: number, transitionDuration: number = 200) {\n        this.moveX = value;\n        this.transformElement(transitionDuration);\n    }\n\n    public setMoveY(value: number, transitionDuration: number = 200) {\n        this.moveY = value;\n        this.transformElement(transitionDuration);\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { PinchZoomComponent } from './pinch-zoom.component'; \n\n@NgModule({\n    declarations: [\n        PinchZoomComponent\n    ],\n    imports: [\n        CommonModule\n    ],\n    exports: [\n        PinchZoomComponent\n    ],\n    entryComponents: [\n        PinchZoomComponent\n    ]\n})\nexport class PinchZoomModule { }\n"]}